using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceCodeEmbeder
{
    class Program
    {
        static void Main(string[] args)
        {
            string sourcePath;
            var options = new HashSet<string>(args.Where(str => str.StartsWith("-")));
            args = args.Where(str => !str.StartsWith("-")).ToArray();
            if (args.Length == 0)
            {
                Console.Error.WriteLine("input source directroy path:");
                sourcePath = Console.ReadLine();
            }
            else
            {
                sourcePath = args[0];
            }
            new Program(sourcePath).Run();
        }

        public Program(string sourcePath) : this(sourcePath, Path.Combine(sourcePath, "Embedded")) { }
        public Program(string sourcePath, string expanderDirPath)
        {
            SourcePath = sourcePath;
            EmbeddedDirPath = expanderDirPath;
        }

        public string SourcePath { get; }
        public string EmbeddedDirPath { get; }

        const string FileTemplate0 = @"using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.CodeDom.Compiler;
namespace AtCoder.Embedded
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute(""SourceCodeEmbedded"", ""1.0.0.0"")]
    public class AclFileInfo
    {
        public string FileName { get; }
        public ReadOnlyCollection<string> TypeNames { get; }
        public ReadOnlyCollection<string> Usings { get; }
        public string CodeBody { get; }
        public AclFileInfo(string fileName, string[] typeNames, string[] usings, string code)
        {
            FileName = fileName;
            TypeNames = new ReadOnlyCollection<string>(typeNames);
            Usings = new ReadOnlyCollection<string>(usings);
            CodeBody = code;
        }
    }
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute(""SourceCodeEmbedded"", ""1.0.0.0"")]
    public static class AutoGenerated__SourceInfo
    {
        public static readonly ReadOnlyCollection<AclFileInfo> FileInfo
            = new ReadOnlyCollection<AclFileInfo>(new AclFileInfo[]
            {
";

        const string FileTemplate1 = @"            });
    }
}
";
        const string AclFileInfoTemplate = @"new AclFileInfo({0}, new string[] {{ {1} }}, new string[] {{ {2} }}, {3}),";

        public void Run()
        {
            var parsedFile = Directory.EnumerateFiles(SourcePath, "*.cs", SearchOption.AllDirectories)
                .ToDictionary(path => path, ParseFile);


            var sb = new StringBuilder();

            foreach (var (path, (typeNames, usings, body)) in parsedFile)
            {
                if (typeNames.Length == 0) continue;
                if (typeNames.All(s => s.StartsWith("AtCoder.Embedded"))) continue;
                var relativePathRaw = path.Split(SourcePath, StringSplitOptions.RemoveEmptyEntries).First();
                var relativePath = $"@\"{relativePathRaw}\"";
                var aclFileInfo = string.Format(AclFileInfoTemplate,
                    relativePath,
                    string.Join(", ", typeNames.Select(s => $"\"{s}\"")),
                    string.Join(", ", usings.Select(s => $"\"{s}\"")),
                    $"@\"{body.Replace("\"", "\"\"")}\"");

                sb.AppendLine(aclFileInfo);
            }

            Directory.CreateDirectory(EmbeddedDirPath);
            File.WriteAllText(Path.Combine(EmbeddedDirPath, "AutoGenerated.cs"),
                FileTemplate0 + sb.ToString() + FileTemplate1);
        }

        private (string[] typeNames, string[] usings, string body) ParseFile(string path) => ParseCode(File.ReadAllText(path));
        private (string[] typeNames, string[] usings, string body) ParseCode(string code) => ParseCode(CSharpSyntaxTree.ParseText(code));
        private (string[] typeNames, string[] usings, string body) ParseCode(SyntaxTree tree)
        {
            var root = (CompilationUnitSyntax)tree.GetRoot();
            var usings = root.Usings.Select(u => u.ToString().Trim()).ToArray();

            var remover = new MinifyRewriter();
            var newRoot = (CompilationUnitSyntax)remover.Visit(root);
            return (GetDeclaratedTypeName(CSharpSyntaxTree.Create(newRoot)), usings, MinifySpace(newRoot.ToString()));
        }

        string[] GetDeclaratedTypeName(SyntaxTree tree)
        {
            var semanticModel = CSharpCompilation.Create("SemanticModel", new[] { tree }).GetSemanticModel(tree);
            var root = tree.GetRoot();
            return root.DescendantNodes()
                .OfType<TypeDeclarationSyntax>()
                .Select(syntax => semanticModel.GetDeclaredSymbol(syntax).ToDisplayString())
                .Distinct()
                .ToArray();
        }

        string MinifySpace(string str) => Regex.Replace(str, " +", " ");
    }
}
public class MinifyRewriter : CSharpSyntaxRewriter
{
    public override SyntaxNode Visit(SyntaxNode node) => base.Visit(node);
    public override SyntaxTrivia VisitTrivia(SyntaxTrivia trivia) => SyntaxFactory.Space;
    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node) => node.Parent.IsKind(SyntaxKind.CompilationUnit) ? default : base.VisitUsingDirective(node);
}
