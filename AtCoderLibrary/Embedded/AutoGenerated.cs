using System.Collections.ObjectModel;
using System.ComponentModel;
using System.CodeDom.Compiler;
namespace AtCoder.Embedded
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public class AclFileInfo
    {
        public string FileName { get; }
        public ReadOnlyCollection<string> TypeNames { get; }
        public ReadOnlyCollection<string> Usings { get; }
        public ReadOnlyCollection<string> Dependencies { get; }
        public string CodeBody { get; }
        public AclFileInfo(string fileName, string[] typeNames, string[] usings, string[] dependencies, string code)
        {
            FileName = fileName;
            TypeNames = new ReadOnlyCollection<string>(typeNames);
            Usings = new ReadOnlyCollection<string>(usings);
            Dependencies = new ReadOnlyCollection<string>(dependencies);
            CodeBody = code;
        }
    }
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public static class AutoGenerated__SourceInfo
    {
        public static readonly ReadOnlyCollection<AclFileInfo> FileInfo
            = new ReadOnlyCollection<AclFileInfo>(new AclFileInfo[]
            {
new AclFileInfo(@"DataStructure/LazySegtree.cs", new string[] { @"AtCoder.IMonoidFuncOperator<T, F>", @"AtCoder.LazySegtree<TValue, F, TOp>", @"AtCoder.LazySegtree<TValue, F, TOp>.DebugItem", @"AtCoder.LazySegtree<TValue, F, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public interface IMonoidFuncOperator<T, F> { T Identity { get; } F FIdentity { get; } T Operate(T x, T y); T Mapping(F f, T x); F Composition(F f, F g); } [DebuggerTypeProxy(typeof(LazySegtree<,,>.DebugView))] public class LazySegtree<TValue, F, TOp> where TOp : struct, IMonoidFuncOperator<TValue, F> { private static readonly TOp op = default; public int Length { get; } private readonly int log; private readonly int size; private readonly TValue[] d; private readonly F[] lz; public LazySegtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); AssertFIdentity(op.Identity); AssertF(op.FIdentity, op.Identity, op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; lz = new F[size]; Array.Fill(d, op.Identity); Array.Fill(lz, op.FIdentity); } public LazySegtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); [MethodImpl(MethodImplOptions.AggressiveInlining)] private void AllApply(int k, F f) { AssertF(f, op.Identity, op.Identity); AssertMonoid(d[k]); AssertFIdentity(d[k]); AssertF(f, d[k], d[k]); d[k] = op.Mapping(f, d[k]); if (k < size) lz[k] = op.Composition(f, lz[k]); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Push(int k) { AllApply(2 * k, lz[k]); AllApply(2 * k + 1, lz[k]); lz[k] = op.FIdentity; } public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); return d[p]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return op.Identity; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push(r >> i); } TValue sml = op.Identity, smr = op.Identity; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } return op.Operate(sml, smr); } public TValue AllProd => d[1]; public void Apply(int p, F f) { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = op.Mapping(f, d[p]); for (int i = 1; i <= log; i++) Update(p >> i); } public void Apply(int l, int r, F f) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push((r - 1) >> i); } { int l2 = l, r2 = r; while (l < r) { if ((l & 1) != 0) AllApply(l++, f); if ((r & 1) != 0) AllApply(--r, f); l >>= 1; r >>= 1; } l = l2; r = r2; } for (int i = 1; i <= log; i++) { if (((l >> i) << i) != l) Update(l >> i); if (((r >> i) << i) != r) Update((r - 1) >> i); } } public int MaxRight(int l, Predicate<TValue> g) { Debug.Assert((uint)l <= Length); Debug.Assert(g(op.Identity)); if (l == Length) return Length; l += size; for (int i = log; i >= 1; i--) Push(l >> i); TValue sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!g(op.Operate(sm, d[l]))) { while (l < size) { Push(l); l = (2 * l); if (g(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> g) { Debug.Assert((uint)r <= Length); Debug.Assert(g(op.Identity)); if (r == 0) return 0; r += size; for (int i = log; i >= 1; i--) Push((r - 1) >> i); TValue sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!g(op.Operate(d[r], sm))) { while (r < size) { Push(r); r = (2 * r + 1); if (g(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return 0; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Lazy = {"" + nameof(lazy) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value, F lazy) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; this.lazy = lazy; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly F lazy; } private class DebugView { private readonly LazySegtree<TValue, F, TOp> segtree; public DebugView(LazySegtree<TValue, F, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) { int dataIndex = i + len; if ((uint)dataIndex < segtree.lz.Length) items.Add(new DebugItem(l, r, segtree.d[dataIndex], segtree.lz[dataIndex])); else items.Add(new DebugItem(l, r, segtree.d[dataIndex], op.FIdentity)); } } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertFIdentity(TValue value) { Debug.Assert(op.Mapping(op.FIdentity, value).Equals(value), $""{nameof(op.Mapping)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertF(F f, TValue v1, TValue v2) { Debug.Assert(op.Mapping(op.FIdentity, op.Operate(v1, v2)).Equals(op.Operate(op.Mapping(op.FIdentity, v1), op.Mapping(op.FIdentity, v2))), $""{nameof(op.Mapping)}({nameof(op.Operate)}({v1}, {v2})) != {nameof(op.Operate)}({nameof(op.Mapping)}({op.Identity}, {v1}), {nameof(op.Mapping)}({op.Identity}, {v2}))""); } } } "),
new AclFileInfo(@"DataStructure/Segtree.cs", new string[] { @"AtCoder.IMonoidOperator<T>", @"AtCoder.Segtree<TValue, TOp>", @"AtCoder.Segtree<TValue, TOp>.DebugItem", @"AtCoder.Segtree<TValue, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public interface IMonoidOperator<T> { T Identity { get; } T Operate(T x, T y); } [DebuggerTypeProxy(typeof(Segtree<,>.DebugView))] public class Segtree<TValue, TOp> where TOp : struct, IMonoidOperator<TValue> { private static readonly TOp op = default; public int Length { get; } private readonly int log; private readonly int size; private readonly TValue[] d; public Segtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; Array.Fill(d, op.Identity); } public Segtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { AssertMonoid(value); Debug.Assert((uint)p < Length); p += size; d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); AssertMonoid(d[p + size]); return d[p + size]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); TValue sml = op.Identity, smr = op.Identity; l += size; r += size; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } AssertMonoid(op.Operate(sml, smr)); return op.Operate(sml, smr); } public TValue AllProd => d[1]; public int MaxRight(int l, Predicate<TValue> f) { Debug.Assert((uint)l <= Length); Debug.Assert(f(op.Identity)); if (l == Length) return Length; l += size; var sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!f(op.Operate(sm, d[l]))) { while (l < size) { l = (2 * l); if (f(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> f) { Debug.Assert((uint)r <= Length); Debug.Assert(f(op.Identity)); if (r == 0) return 0; r += size; var sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!f(op.Operate(d[r], sm))) { while (r < size) { r = (2 * r + 1); if (f(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return 0; } [DebuggerDisplay(""{"" + nameof(value) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; } private class DebugView { private readonly Segtree<TValue, TOp> segtree; public DebugView(Segtree<TValue, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) items.Add(new DebugItem(l, r, segtree.d[i + len])); } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } } } "),
new AclFileInfo(@"DataStructure/FenwickTree.cs", new string[] { @"AtCoder.IntFenwickTree", @"AtCoder.UIntFenwickTree", @"AtCoder.LongFenwickTree", @"AtCoder.ULongFenwickTree", @"AtCoder.ModIntFenwickTree<T>", @"AtCoder.FenwickTree<TValue, TOp>", @"AtCoder.FenwickTree<TValue, TOp>.DebugItem", @"AtCoder.FenwickTree<TValue, TOp>.DebugView" }, new string[] { @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Algebra/Operators.cs", @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public class IntFenwickTree : FenwickTree<int, IntOperator> { public IntFenwickTree(int n) : base(n) { } } public class UIntFenwickTree : FenwickTree<uint, UIntOperator> { public UIntFenwickTree(int n) : base(n) { } } public class LongFenwickTree : FenwickTree<long, LongOperator> { public LongFenwickTree(int n) : base(n) { } } public class ULongFenwickTree : FenwickTree<ulong, ULongOperator> { public ULongFenwickTree(int n) : base(n) { } } public class ModIntFenwickTree<T> : FenwickTree<StaticModInt<T>, StaticModIntOperator<T>> where T : struct, IStaticMod { public ModIntFenwickTree(int n) : base(n) { } } [DebuggerTypeProxy(typeof(FenwickTree<,>.DebugView))] public class FenwickTree<TValue, TOp> where TOp : IAddOperator<TValue>, ISubtractOperator<TValue> { private static readonly TOp op = default; private readonly TValue[] data; public FenwickTree(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); data = new TValue[n + 1]; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Add(int p, TValue x) { Debug.Assert(unchecked((uint)p < data.Length)); for (p++; p < data.Length; p += InternalBit.ExtractLowestSetBit(p)) { data[p] = op.Add(data[p], x); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Sum(int l, int r) { Debug.Assert(0 <= l && l <= r && r < data.Length); return op.Subtract(Sum(r), Sum(l)); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private TValue Sum(int r) { TValue s = default; for (; r > 0; r -= InternalBit.ExtractLowestSetBit(r)) { s = op.Add(s, data[r]); } return s; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Sum = {"" + nameof(sum) + ""}"")] internal struct DebugItem { public DebugItem(TValue value, TValue sum) { this.sum = sum; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue sum; } internal class DebugView { private readonly FenwickTree<TValue, TOp> fenwickTree; public DebugView(FenwickTree<TValue, TOp> fenwickTree) { this.fenwickTree = fenwickTree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var data = fenwickTree.data; var items = new DebugItem[data.Length - 1]; items[0] = new DebugItem(data[1], data[1]); for (int i = 2; i < data.Length; i++) { int length = InternalBit.ExtractLowestSetBit(i); var pr = i - length - 1; var sum = op.Add(data[i], 0 <= pr ? items[pr].sum : default); var val = op.Subtract(sum, items[i - 2].sum); items[i - 1] = new DebugItem(val, sum); } return items; } } } } } "),
new AclFileInfo(@"Algebra/Operators.cs", new string[] { @"AtCoder.IAddOperator<T>", @"AtCoder.ISubtractOperator<T>", @"AtCoder.IMultiplyOperator<T>", @"AtCoder.IDivideOperator<T>", @"AtCoder.IModuloOperator<T>", @"AtCoder.INegateOperator<T>", @"AtCoder.IIncrementOperator<T>", @"AtCoder.IDecrementOperator<T>", @"AtCoder.IComparisonOperator<T>", @"AtCoder.IRangedType<T>", @"AtCoder.IUnsignedNumOperator<T>", @"AtCoder.ISignedNumOperator<T>", @"AtCoder.IntOperator", @"AtCoder.LongOperator", @"AtCoder.UIntOperator", @"AtCoder.ULongOperator", @"AtCoder.DoubleOperator" }, new string[] { @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder { public interface IAddOperator<T> { T Add(T x, T y); } public interface ISubtractOperator<T> { T Subtract(T x, T y); } public interface IMultiplyOperator<T> { T Multiply(T x, T y); } public interface IDivideOperator<T> { T Divide(T x, T y); } public interface IModuloOperator<T> { T Modulo(T x, T y); } public interface INegateOperator<T> { T Negate(T x); } public interface IIncrementOperator<T> : IAddOperator<T> { T Increment(T x); } public interface IDecrementOperator<T> : ISubtractOperator<T> { T Decrement(T x); } public interface IComparisonOperator<T> : IComparer<T> { bool GreaterThan(T x, T y); bool GreaterThanOrEqual(T x, T y); bool LessThan(T x, T y); bool LessThanOrEqual(T x, T y); } public interface IRangedType<T> { public T MinValue { get; } public T MaxValue { get; } } public interface IUnsignedNumOperator<T> : IAddOperator<T>, ISubtractOperator<T>, IMultiplyOperator<T>, IDivideOperator<T>, IModuloOperator<T>, IIncrementOperator<T>, IDecrementOperator<T>, IComparisonOperator<T>, IRangedType<T>, IEqualityComparer<T> { } public interface ISignedNumOperator<T> : IUnsignedNumOperator<T>, INegateOperator<T> { } public readonly struct IntOperator : ISignedNumOperator<int> { public int MinValue => int.MinValue; public int MaxValue => int.MaxValue; public int Add(int x, int y) => x + y; public int Subtract(int x, int y) => x - y; public int Multiply(int x, int y) => x * y; public int Divide(int x, int y) => x / y; public int Modulo(int x, int y) => x % y; public int Negate(int x) => -x; public int Increment(int x) => ++x; public int Decrement(int x) => --x; public bool GreaterThan(int x, int y) => x > y; public bool GreaterThanOrEqual(int x, int y) => x >= y; public bool LessThan(int x, int y) => x < y; public bool LessThanOrEqual(int x, int y) => x <= y; public int Compare(int x, int y) => x.CompareTo(y); public bool Equals(int x, int y) => x == y; public int GetHashCode(int obj) => obj.GetHashCode(); } public readonly struct LongOperator : ISignedNumOperator<long> { public long MinValue => long.MinValue; public long MaxValue => long.MaxValue; public long Add(long x, long y) => x + y; public long Subtract(long x, long y) => x - y; public long Multiply(long x, long y) => x * y; public long Divide(long x, long y) => x / y; public long Modulo(long x, long y) => x % y; public long Negate(long x) => -x; public long Increment(long x) => ++x; public long Decrement(long x) => --x; public bool GreaterThan(long x, long y) => x > y; public bool GreaterThanOrEqual(long x, long y) => x >= y; public bool LessThan(long x, long y) => x < y; public bool LessThanOrEqual(long x, long y) => x <= y; public int Compare(long x, long y) => x.CompareTo(y); public bool Equals(long x, long y) => x == y; public int GetHashCode(long obj) => obj.GetHashCode(); } public readonly struct UIntOperator : IUnsignedNumOperator<uint> { public uint MinValue => uint.MinValue; public uint MaxValue => uint.MaxValue; public uint Add(uint x, uint y) => x + y; public uint Subtract(uint x, uint y) => x - y; public uint Multiply(uint x, uint y) => x * y; public uint Divide(uint x, uint y) => x / y; public uint Modulo(uint x, uint y) => x % y; public uint Increment(uint x) => ++x; public uint Decrement(uint x) => --x; public bool GreaterThan(uint x, uint y) => x > y; public bool GreaterThanOrEqual(uint x, uint y) => x >= y; public bool LessThan(uint x, uint y) => x < y; public bool LessThanOrEqual(uint x, uint y) => x <= y; public int Compare(uint x, uint y) => x.CompareTo(y); public bool Equals(uint x, uint y) => x == y; public int GetHashCode(uint obj) => obj.GetHashCode(); } public readonly struct ULongOperator : IUnsignedNumOperator<ulong> { public ulong MinValue => ulong.MinValue; public ulong MaxValue => ulong.MaxValue; public ulong Add(ulong x, ulong y) => x + y; public ulong Subtract(ulong x, ulong y) => x - y; public ulong Multiply(ulong x, ulong y) => x * y; public ulong Divide(ulong x, ulong y) => x / y; public ulong Modulo(ulong x, ulong y) => x % y; public ulong Increment(ulong x) => ++x; public ulong Decrement(ulong x) => --x; public bool GreaterThan(ulong x, ulong y) => x > y; public bool GreaterThanOrEqual(ulong x, ulong y) => x >= y; public bool LessThan(ulong x, ulong y) => x < y; public bool LessThanOrEqual(ulong x, ulong y) => x <= y; public int Compare(ulong x, ulong y) => x.CompareTo(y); public bool Equals(ulong x, ulong y) => x == y; public int GetHashCode(ulong obj) => obj.GetHashCode(); } public readonly struct DoubleOperator : ISignedNumOperator<double> { public double MinValue => double.MinValue; public double MaxValue => double.MaxValue; public double Add(double x, double y) => x + y; public double Subtract(double x, double y) => x - y; public double Multiply(double x, double y) => x * y; public double Divide(double x, double y) => x / y; public double Modulo(double x, double y) => x % y; public double Negate(double x) => -x; public double Increment(double x) => ++x; public double Decrement(double x) => --x; public bool GreaterThan(double x, double y) => x > y; public bool GreaterThanOrEqual(double x, double y) => x >= y; public bool LessThan(double x, double y) => x < y; public bool LessThanOrEqual(double x, double y) => x <= y; public int Compare(double x, double y) => x.CompareTo(y); public bool Equals(double x, double y) => x == y; public int GetHashCode(double obj) => obj.GetHashCode(); } } "),
new AclFileInfo(@"Math/MathLib.cs", new string[] { @"AtCoder.MathLib", @"AtCoder.MathLib.FFTMod1", @"AtCoder.MathLib.FFTMod2", @"AtCoder.MathLib.FFTMod3" }, new string[] { @"using System;", @"using System.Diagnostics;", @"using System.Linq;", @"using AtCoder.Internal;" }, new string[] { @"Math/Internal/Barrett.cs", @"Math/Internal/InternalMath.cs", @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/Butterfly.cs" }, @"namespace AtCoder { public static class MathLib { public static long PowMod(long x, long n, int m) { Debug.Assert(0 <= n && 1 <= m); if (m == 1) return 0; Barrett barrett = new Barrett((uint)m); uint r = 1, y = (uint)InternalMath.SafeMod(x, m); while (0 < n) { if ((n & 1) != 0) r = barrett.Mul(r, y); y = barrett.Mul(y, y); n >>= 1; } return r; } public static long InvMod(long x, int m) { Debug.Assert(1 <= m); var (g, res) = InternalMath.InvGCD(x, m); Debug.Assert(g == 1); return res; } public static (long, long) CRT(long[] r, long[] m) { Debug.Assert(r.Length == m.Length); long r0 = 0, m0 = 1; for (int i = 0; i < m.Length; i++) { Debug.Assert(1 <= m[i]); long r1 = InternalMath.SafeMod(r[i], m[i]); long m1 = m[i]; if (m0 < m1) { (r0, r1) = (r1, r0); (m0, m1) = (m1, m0); } if (m0 % m1 == 0) { if (r0 % m1 != r1) return (0, 0); continue; } var (g, im) = InternalMath.InvGCD(m0, m1); long u1 = (m1 / g); if ((r1 - r0) % g != 0) return (0, 0); long x = (r1 - r0) / g % u1 * im % u1; r0 += x * m0; m0 *= u1; if (r0 < 0) r0 += m0; } return (r0, m0); } public static long FloorSum(long n, long m, long a, long b) { long ans = 0; while (true) { if (a >= m) { ans += (n - 1) * n * (a / m) / 2; a %= m; } if (b >= m) { ans += n * (b / m); b %= m; } long yMax = (a * n + b) / m; long xMax = yMax * m - b; if (yMax == 0) return ans; ans += (n - (xMax + a - 1) / a) * yMax; (n, m, a, b) = (yMax, a, m, (a - xMax % a) % a); } } public static int[] Convolution(int[] a, int[] b) => Convolution<Mod998244353>(a, b); public static uint[] Convolution(uint[] a, uint[] b) => Convolution<Mod998244353>(a, b); public static long[] Convolution(long[] a, long[] b) => Convolution<Mod998244353>(a, b); public static ulong[] Convolution(ulong[] a, ulong[] b) => Convolution<Mod998244353>(a, b); public static int[] Convolution<TMod>(int[] a, int[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<int>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new int[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static uint[] Convolution<TMod>(uint[] a, uint[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<uint>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (uint)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new uint[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (uint)c[i].Value; } return result; } } public static long[] Convolution<TMod>(long[] a, long[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (long)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new long[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static ulong[] Convolution<TMod>(ulong[] a, ulong[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<ulong>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(TakeMod).ToArray(), b.Select(TakeMod).ToArray()); return c.Select(ci => (ulong)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = TakeMod(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = TakeMod(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } StaticModInt<TMod> TakeMod(ulong x) => StaticModInt<TMod>.Raw((int)(x % default(TMod).Mod)); } public static StaticModInt<TMod>[] Convolution<TMod>(StaticModInt<TMod>[] a, StaticModInt<TMod>[] b) where TMod : struct, IStaticMod { var temp = Convolution((ReadOnlySpan<StaticModInt<TMod>>)a, b); return temp.ToArray(); } public static Span<StaticModInt<TMod>> Convolution<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<StaticModInt<TMod>>(); } if (Math.Min(n, m) <= 60) { return ConvolutionNaive(a, b); } int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; a.CopyTo(aTemp); var bTemp = new StaticModInt<TMod>[z]; b.CopyTo(bTemp); return Convolution(aTemp.AsSpan(), bTemp.AsSpan(), n, m, z); } private static Span<StaticModInt<TMod>> Convolution<TMod>(Span<StaticModInt<TMod>> a, Span<StaticModInt<TMod>> b, int n, int m, int z) where TMod : struct, IStaticMod { Internal.Butterfly<TMod>.Calculate(a); Internal.Butterfly<TMod>.Calculate(b); for (int i = 0; i < a.Length; i++) { a[i] *= b[i]; } Internal.Butterfly<TMod>.CalculateInv(a); var result = a[0..(n + m - 1)]; var iz = new StaticModInt<TMod>(z).Inv(); foreach (ref var r in result) { r *= iz; } return result; } public static long[] ConvolutionLong(ReadOnlySpan<long> a, ReadOnlySpan<long> b) { unchecked { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } const ulong Mod1 = 754974721; const ulong Mod2 = 167772161; const ulong Mod3 = 469762049; const ulong M2M3 = Mod2 * Mod3; const ulong M1M3 = Mod1 * Mod3; const ulong M1M2 = Mod1 * Mod2; const ulong M1M2M3 = Mod1 * Mod2 * Mod3; ulong i1 = (ulong)Internal.InternalMath.InvGCD((long)M2M3, (long)Mod1).Item2; ulong i2 = (ulong)Internal.InternalMath.InvGCD((long)M1M3, (long)Mod2).Item2; ulong i3 = (ulong)Internal.InternalMath.InvGCD((long)M1M2, (long)Mod3).Item2; var c1 = Convolution<FFTMod1>(a, b); var c2 = Convolution<FFTMod2>(a, b); var c3 = Convolution<FFTMod3>(a, b); var c = new long[n + m - 1]; Span<ulong> offset = stackalloc ulong[] { 0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 }; for (int i = 0; i < c.Length; i++) { ulong x = 0; x += (c1[i] * i1) % Mod1 * M2M3; x += (c2[i] * i2) % Mod2 * M1M3; x += (c3[i] * i3) % Mod3 * M1M2; long diff = (long)c1[i] - Internal.InternalMath.SafeMod((long)x, (long)Mod1); if (diff < 0) { diff += (long)Mod1; } x -= offset[(int)(diff % offset.Length)]; c[i] = (long)x; } return c; } ulong[] Convolution<TMod>(ReadOnlySpan<long> a, ReadOnlySpan<long> b) where TMod : struct, IStaticMod { int z = 1 << Internal.InternalBit.CeilPow2(a.Length + b.Length - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = AtCoder.MathLib.Convolution<TMod>(aTemp, bTemp, a.Length, b.Length, z); var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } } private static StaticModInt<TMod>[] ConvolutionNaive<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { if (a.Length < b.Length) { var temp = a; a = b; b = temp; } var ans = new StaticModInt<TMod>[a.Length + b.Length - 1]; for (int i = 0; i < a.Length; i++) { for (int j = 0; j < b.Length; j++) { ans[i + j] += a[i] * b[j]; } } return ans; } private readonly struct FFTMod1 : IStaticMod { public uint Mod => 754974721; public bool IsPrime => true; } private readonly struct FFTMod2 : IStaticMod { public uint Mod => 167772161; public bool IsPrime => true; } private readonly struct FFTMod3 : IStaticMod { public uint Mod => 469762049; public bool IsPrime => true; } } } "),
new AclFileInfo(@"Math/ModInt.cs", new string[] { @"AtCoder.IStaticMod", @"AtCoder.Mod1000000007", @"AtCoder.Mod998244353", @"AtCoder.IDynamicModID", @"AtCoder.ModID0", @"AtCoder.ModID1", @"AtCoder.ModID2", @"AtCoder.StaticModIntOperator<T>", @"AtCoder.StaticModInt<T>", @"AtCoder.DynamicModInt<T>" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Algebra/Operators.cs", @"Math/Internal/InternalMath.cs", @"Math/Internal/Barrett.cs" }, @"namespace AtCoder { public interface IStaticMod { uint Mod { get; } bool IsPrime { get; } } public readonly struct Mod1000000007 : IStaticMod { public uint Mod => 1000000007; public bool IsPrime => true; } public readonly struct Mod998244353 : IStaticMod { public uint Mod => 998244353; public bool IsPrime => true; } public interface IDynamicModID { } public readonly struct ModID0 : IDynamicModID { } public readonly struct ModID1 : IDynamicModID { } public readonly struct ModID2 : IDynamicModID { } public readonly struct StaticModIntOperator<T> : IAddOperator<StaticModInt<T>>, ISubtractOperator<StaticModInt<T>>, IMultiplyOperator<StaticModInt<T>>, IDivideOperator<StaticModInt<T>>, IIncrementOperator<StaticModInt<T>>, IDecrementOperator<StaticModInt<T>>, INegateOperator<StaticModInt<T>>, IEqualityComparer<StaticModInt<T>> where T : struct, IStaticMod { public StaticModInt<T> Add(StaticModInt<T> x, StaticModInt<T> y) => x + y; public StaticModInt<T> Subtract(StaticModInt<T> x, StaticModInt<T> y) => x - y; public StaticModInt<T> Multiply(StaticModInt<T> x, StaticModInt<T> y) => x * y; public StaticModInt<T> Divide(StaticModInt<T> x, StaticModInt<T> y) => x / y; public StaticModInt<T> Negate(StaticModInt<T> x) => -x; public StaticModInt<T> Increment(StaticModInt<T> x) => ++x; public StaticModInt<T> Decrement(StaticModInt<T> x) => --x; public bool Equals(StaticModInt<T> x, StaticModInt<T> y) => x == y; public int GetHashCode(StaticModInt<T> obj) => obj.GetHashCode(); } public readonly struct StaticModInt<T> where T : struct, IStaticMod { private readonly uint _v; public int Value => (int)_v; public static int Mod => (int)default(T).Mod; public static StaticModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(u < Mod); return new StaticModInt<T>(u); } public StaticModInt(long v) : this(Round(v)) { } private StaticModInt(uint v) => _v = v; private static uint Round(long v) { var x = v % default(T).Mod; if (x < 0) { x += default(T).Mod; } return (uint)x; } public static StaticModInt<T> operator ++(StaticModInt<T> value) { var v = value._v + 1; if (v == default(T).Mod) { v = 0; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator --(StaticModInt<T> value) { var v = value._v; if (v == 0) { v = default(T).Mod; } return new StaticModInt<T>(v - 1); } public static StaticModInt<T> operator +(StaticModInt<T> lhs, StaticModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= default(T).Mod) { v -= default(T).Mod; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator -(StaticModInt<T> lhs, StaticModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= default(T).Mod) { v += default(T).Mod; } return new StaticModInt<T>(v); } } public static StaticModInt<T> operator *(StaticModInt<T> lhs, StaticModInt<T> rhs) { return new StaticModInt<T>((uint)((ulong)lhs._v * rhs._v % default(T).Mod)); } public static StaticModInt<T> operator /(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs * rhs.Inv(); public static StaticModInt<T> operator +(StaticModInt<T> value) => value; public static StaticModInt<T> operator -(StaticModInt<T> value) => new StaticModInt<T>() - value; public static bool operator ==(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator StaticModInt<T>(int value) => new StaticModInt<T>(value); public static implicit operator StaticModInt<T>(long value) => new StaticModInt<T>(value); public StaticModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new StaticModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public StaticModInt<T> Inv() { if (default(T).IsPrime) { Debug.Assert(_v > 0); return Pow(default(T).Mod - 2); } else { var (g, x) = Internal.InternalMath.InvGCD(_v, default(T).Mod); Debug.Assert(g == 1); return new StaticModInt<T>(x); } } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is StaticModInt<T> && this == (StaticModInt<T>)obj; public override int GetHashCode() => _v.GetHashCode(); } public readonly struct DynamicModInt<T> where T : struct, IDynamicModID { private readonly uint _v; private static Internal.Barrett bt; public int Value => (int)_v; public static int Mod { get => (int)bt.Mod; set { Debug.Assert(1 <= value); bt = new Internal.Barrett((uint)value); } } public static DynamicModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(bt != null, $""使用前に {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)} プロパティに mod の値を設定してください。""); Debug.Assert(u < Mod); return new DynamicModInt<T>(u); } public DynamicModInt(long v) : this(Round(v)) { } private DynamicModInt(uint v) => _v = v; private static uint Round(long v) { Debug.Assert(bt != null, $""使用前に {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)} プロパティに mod の値を設定してください。""); var x = v % bt.Mod; if (x < 0) { x += bt.Mod; } return (uint)x; } public static DynamicModInt<T> operator ++(DynamicModInt<T> value) { var v = value._v + 1; if (v == bt.Mod) { v = 0; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator --(DynamicModInt<T> value) { var v = value._v; if (v == 0) { v = bt.Mod; } return new DynamicModInt<T>(v - 1); } public static DynamicModInt<T> operator +(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= bt.Mod) { v -= bt.Mod; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator -(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= bt.Mod) { v += bt.Mod; } return new DynamicModInt<T>(v); } } public static DynamicModInt<T> operator *(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { uint z = bt.Mul(lhs._v, rhs._v); return new DynamicModInt<T>(z); } public static DynamicModInt<T> operator /(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs * rhs.Inv(); public static DynamicModInt<T> operator +(DynamicModInt<T> value) => value; public static DynamicModInt<T> operator -(DynamicModInt<T> value) => new DynamicModInt<T>() - value; public static bool operator ==(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator DynamicModInt<T>(int value) => new DynamicModInt<T>(value); public static implicit operator DynamicModInt<T>(long value) => new DynamicModInt<T>(value); public DynamicModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new DynamicModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public DynamicModInt<T> Inv() { var (g, x) = Internal.InternalMath.InvGCD(_v, bt.Mod); Debug.Assert(g == 1); return new DynamicModInt<T>(x); } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is DynamicModInt<T> && this == (DynamicModInt<T>)obj; public override int GetHashCode() => _v.GetHashCode(); } } "),
new AclFileInfo(@"Graph/MaxFlow.cs", new string[] { @"AtCoder.MFGraphInt", @"AtCoder.MFGraphLong", @"AtCoder.MFGraph<TValue, TOp>", @"AtCoder.MFGraph<TValue, TOp>.Edge", @"AtCoder.MFGraph<TValue, TOp>.EdgeInternal" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder { public class MFGraphInt : MFGraph<int, IntOperator> { public MFGraphInt(int n) : base(n) { } } public class MFGraphLong : MFGraph<long, LongOperator> { public MFGraphLong(int n) : base(n) { } } public class MFGraph<TValue, TOp> where TOp : ISignedNumOperator<TValue> { static readonly TOp op = default; public MFGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TValue cap) { int m = _pos.Count; Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); Debug.Assert(op.LessThanOrEqual(default, cap)); _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default)); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, op.Add(_e.Cap, _re.Cap), _re.Cap); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public void ChangeEdge(int i, TValue newCap, TValue newFlow) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); Debug.Assert(op.LessThanOrEqual(default, newFlow) && op.LessThanOrEqual(newFlow, newCap)); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; _e.Cap = op.Subtract(newCap, newFlow); _re.Cap = newFlow; } public TValue Flow(int s, int t) { return Flow(s, t, op.MaxValue); } public TValue Flow(int s, int t, TValue flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); var level = new int[_n]; var iter = new int[_n]; var que = new Queue<int>(); void Bfs() { for (int i = 0; i < _n; i++) { level[i] = -1; } level[s] = 0; que.Clear(); que.Enqueue(s); while (que.Count > 0) { int v = que.Dequeue(); foreach (var e in _g[v]) { if (op.Equals(e.Cap, default) || level[e.To] >= 0) continue; level[e.To] = level[v] + 1; if (e.To == t) return; que.Enqueue(e.To); } } } TValue Dfs(int v, TValue up) { if (v == s) return up; var res = default(TValue); int level_v = level[v]; for (; iter[v] < _g[v].Count; iter[v]++) { EdgeInternal e = _g[v][iter[v]]; if (level_v <= level[e.To] || op.Equals(_g[e.To][e.Rev].Cap, default)) continue; var up1 = op.Subtract(up, res); var up2 = _g[e.To][e.Rev].Cap; var d = Dfs(e.To, op.LessThan(up1, up2) ? up1 : up2); if (op.Compare(d, default) <= 0) continue; _g[v][iter[v]].Cap = op.Add(_g[v][iter[v]].Cap, d); _g[e.To][e.Rev].Cap = op.Subtract(_g[e.To][e.Rev].Cap, d); res = op.Add(res, d); if (res.Equals(up)) break; } return res; } TValue flow = default; while (op.LessThan(flow, flowLimit)) { Bfs(); if (level[t] == -1) break; for (int i = 0; i < _n; i++) { iter[i] = 0; } while (op.LessThan(flow, flowLimit)) { var f = Dfs(t, op.Subtract(flowLimit, flow)); if (op.Equals(f, default)) break; flow = op.Add(flow, f); } } return flow; } public bool[] MinCut(int s) { var visited = new bool[_n]; var que = new Queue<int>(); que.Enqueue(s); while (que.Count > 0) { int p = que.Dequeue(); visited[p] = true; foreach (var e in _g[p]) { if (!op.Equals(e.Cap, default) && !visited[e.To]) { visited[e.To] = true; que.Enqueue(e.To); } } } return visited; } public struct Edge { public int From { get; set; } public int To { get; set; } public TValue Cap { get; set; } public TValue Flow { get; set; } public Edge(int from, int to, TValue cap, TValue flow) { From = from; To = to; Cap = cap; Flow = flow; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TValue Cap { get; set; } public EdgeInternal(int to, int rev, TValue cap) { To = to; Rev = rev; Cap = cap; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; } } "),
new AclFileInfo(@"Graph/TwoSat.cs", new string[] { @"AtCoder.TwoSat" }, new string[] { @"using System.Diagnostics;" }, new string[] { @"Graph/SCCGraph.cs" }, @"namespace AtCoder { [DebuggerDisplay(""Count = {_n}"")] public class TwoSat { readonly int _n; readonly private bool[] _answer; readonly private SCCGraph scc; public TwoSat(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _n = n; _answer = new bool[n]; scc = new SCCGraph(2 * n); } public void AddClause(int i, bool f, int j, bool g) { Debug.Assert(unchecked((uint)i < _n)); Debug.Assert(unchecked((uint)j < _n)); scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0)); scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0)); } public bool Satisfiable() { var sccs = scc.SCC(); var id = new int[2 * _n]; for (int i = 0; i < sccs.Count; i++) { foreach (var v in sccs[i]) { id[v] = i; } } for (int i = 0; i < _n; i++) { if (id[2 * i] == id[2 * i + 1]) { return false; } else { _answer[i] = id[2 * i] < id[2 * i + 1]; } } return true; } public bool[] Answer() => _answer; } } "),
new AclFileInfo(@"Graph/MinCostFlow.cs", new string[] { @"AtCoder.ICastOperator<TFrom, TTo>", @"AtCoder.SameTypeCastOperator<T>", @"AtCoder.IntToLongCastOperator", @"AtCoder.McfGraphInt", @"AtCoder.McfGraphLong", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.Edge", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.EdgeInternal", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.PriorityQueueForMcf" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Runtime.CompilerServices;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder { public interface ICastOperator<TFrom, TTo> where TFrom : struct where TTo : struct { TTo Cast(TFrom y); } public struct SameTypeCastOperator<T> : ICastOperator<T, T> where T : struct { public T Cast(T y) => y; } public struct IntToLongCastOperator : ICastOperator<int, long> { public long Cast(int y) => y; } public class McfGraphInt : McfGraph<int, IntOperator, int, IntOperator, SameTypeCastOperator<int>> { public McfGraphInt(int n) : base(n) { } } public class McfGraphLong : McfGraph<long, LongOperator, long, LongOperator, SameTypeCastOperator<long>> { public McfGraphLong(int n) : base(n) { } } public class McfGraph<TCap, TCapOp, TCost, TCostOp, TCast> where TCap : struct where TCapOp : struct, ISignedNumOperator<TCap> where TCost : struct where TCostOp : struct, ISignedNumOperator<TCost> where TCast : ICastOperator<TCap, TCost> { static readonly TCapOp capOp = default; static readonly TCostOp costOp = default; static readonly TCast cast = default; public McfGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TCap cap, TCost cost) { Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); int m = _pos.Count; _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap, cost)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default, costOp.Negate(cost))); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, capOp.Add(_e.Cap, _re.Cap), _re.Cap, _e.Cost); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public (TCap cap, TCost cost) Flow(int s, int t) { return Flow(s, t, capOp.MaxValue); } public (TCap cap, TCost cost) Flow(int s, int t, TCap flowLimit) { return Slope(s, t, flowLimit).Last(); } public List<(TCap cap, TCost cost)> Slope(int s, int t) { return Slope(s, t, capOp.MaxValue); } public List<(TCap cap, TCost cost)> Slope(int s, int t, TCap flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); Debug.Assert(s != t); var dual = new TCost[_n]; var dist = new TCost[_n]; var pv = new int[_n]; var pe = new int[_n]; var vis = new bool[_n]; bool DualRef() { dist.AsSpan().Fill(costOp.MaxValue); pv.AsSpan().Fill(-1); pe.AsSpan().Fill(-1); vis.AsSpan().Fill(false); var que = new PriorityQueueForMcf(); dist[s] = default; que.Enqueue(default, s); while (que.Count > 0) { int v = que.Dequeue().to; if (vis[v]) continue; vis[v] = true; if (v == t) break; for (int i = 0; i < _g[v].Count; i++) { var e = _g[v][i]; if (vis[e.To] || capOp.Equals(e.Cap, default)) continue; TCost cost = costOp.Add(costOp.Subtract(e.Cost, dual[e.To]), dual[v]); if (costOp.GreaterThan(costOp.Subtract(dist[e.To], dist[v]), cost)) { dist[e.To] = costOp.Add(dist[v], cost); pv[e.To] = v; pe[e.To] = i; que.Enqueue(dist[e.To], e.To); } } } if (!vis[t]) { return false; } for (int v = 0; v < _n; v++) { if (!vis[v]) continue; dual[v] = costOp.Subtract(dual[v], costOp.Subtract(dist[t], dist[v])); } return true; } TCap flow = default; TCost cost = default; TCost prev_cost = costOp.Decrement(default); var result = new List<(TCap cap, TCost cost)>(); result.Add((flow, cost)); while (capOp.LessThan(flow, flowLimit)) { if (!DualRef()) break; TCap c = capOp.Subtract(flowLimit, flow); for (int v = t; v != s; v = pv[v]) { if (capOp.LessThan(_g[pv[v]][pe[v]].Cap, c)) { c = _g[pv[v]][pe[v]].Cap; } } for (int v = t; v != s; v = pv[v]) { _g[pv[v]][pe[v]].Cap = capOp.Subtract(_g[pv[v]][pe[v]].Cap, c); _g[v][_g[pv[v]][pe[v]].Rev].Cap = capOp.Add(_g[v][_g[pv[v]][pe[v]].Rev].Cap, c); } TCost d = costOp.Negate(dual[s]); flow = capOp.Add(flow, c); cost = costOp.Add(cost, costOp.Multiply(cast.Cast(c), d)); if (costOp.Equals(prev_cost, d)) { result.RemoveAt(result.Count - 1); } result.Add((flow, cost)); prev_cost = cost; } return result; } public struct Edge { public int From { get; set; } public int To { get; set; } public TCap Cap { get; set; } public TCap Flow { get; set; } public TCost Cost { get; set; } public Edge(int from, int to, TCap cap, TCap flow, TCost cost) { From = from; To = to; Cap = cap; Flow = flow; Cost = cost; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TCap Cap { get; set; } public TCost Cost { get; set; } public EdgeInternal(int to, int rev, TCap cap, TCost cost) { To = to; Rev = rev; Cap = cap; Cost = cost; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; private class PriorityQueueForMcf { private (TCost cost, int to)[] _heap; public int Count { get; private set; } = 0; public PriorityQueueForMcf() { _heap = new (TCost cost, int to)[1024]; } public void Enqueue(TCost cost, int to) { var pair = (cost, to); if (_heap.Length == Count) { var newHeap = new (TCost cost, int to)[_heap.Length * 2]; _heap.CopyTo(newHeap, 0); _heap = newHeap; } _heap[Count] = pair; ++Count; int c = Count - 1; while (c > 0) { int p = (c - 1) >> 1; if (Compare(_heap[p].cost, cost) < 0) { _heap[c] = _heap[p]; c = p; } else { break; } } _heap[c] = pair; } public (TCost cost, int to) Dequeue() { (TCost cost, int to) ret = _heap[0]; int n = Count - 1; var item = _heap[n]; int p = 0; int c = (p << 1) + 1; while (c < n) { if (c != n - 1 && Compare(_heap[c + 1].cost, _heap[c].cost) > 0) { ++c; } if (Compare(item.cost, _heap[c].cost) < 0) { _heap[p] = _heap[c]; p = c; c = (p << 1) + 1; } else { break; } } _heap[p] = item; Count--; return ret; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int Compare(TCost x, TCost y) => costOp.Compare(y, x); } } } "),
new AclFileInfo(@"Graph/DSU.cs", new string[] { @"AtCoder.DSU" }, new string[] { @"using System;", @"using System.Diagnostics;" }, new string[] {  }, @"namespace AtCoder { public class DSU { private int Count; private int[] ParentOrSize; public DSU(int n) { Count = n; ParentOrSize = new int[n]; for (int i = 0; i < ParentOrSize.Length; i++) ParentOrSize[i] = -1; } public int Merge(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); int x = Leader(a), y = Leader(b); if (x == y) return x; if (-ParentOrSize[x] < -ParentOrSize[y]) (x, y) = (y, x); ParentOrSize[x] += ParentOrSize[y]; ParentOrSize[y] = x; return x; } public bool Same(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); return Leader(a) == Leader(b); } public int Leader(int a) { if (ParentOrSize[a] < 0) return a; while (0 <= ParentOrSize[ParentOrSize[a]]) { (a, ParentOrSize[a]) = (ParentOrSize[a], ParentOrSize[ParentOrSize[a]]); } return ParentOrSize[a]; } public int Size(int a) { Debug.Assert(0 <= a && a < Count); return -ParentOrSize[Leader(a)]; } public Span<int[]> Groups() { int[] leaderBuf = new int[Count]; int[] id = new int[Count]; Span<int[]> result = new int[Count][]; int groupCount = 0; for (int i = 0; i < leaderBuf.Length; i++) { leaderBuf[i] = Leader(i); if (i == leaderBuf[i]) { id[i] = groupCount; result[id[i]] = new int[-ParentOrSize[i]]; groupCount++; } } int[] ind = new int[groupCount]; result = result.Slice(0, groupCount); for (int i = 0; i < leaderBuf.Length; i++) { var leaderID = id[leaderBuf[i]]; result[leaderID][ind[leaderID]] = i; ind[leaderID]++; } return result; } } } "),
new AclFileInfo(@"Graph/SCCGraph.cs", new string[] { @"AtCoder.SCCGraph" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Graph/Internal/InternalSCCGraph.cs" }, @"namespace AtCoder { [DebuggerDisplay(""Vertices = {_internal._n}, Edges = {_internal.edges.Count}"")] public class SCCGraph { Internal.SCCGraph _internal; public SCCGraph(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _internal = new Internal.SCCGraph(n); } public void AddEdge(int from, int to) { int n = _internal.VerticesNumbers; Debug.Assert(unchecked((uint)from < n)); Debug.Assert(unchecked((uint)to < n)); _internal.AddEdge(from, to); } public List<List<int>> SCC() => _internal.SCC(); } } "),
new AclFileInfo(@"DataStructure/String/ZAlgorithm.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder { public static partial class StringLib { public static int[] ZAlgorithm<T>(ReadOnlySpan<T> s) { int n = s.Length; if (n == 0) return new int[] { }; int[] z = new int[n]; z[0] = 0; for (int i = 1, j = 0; i < n; i++) { ref int k = ref z[i]; k = (j + z[j] <= i) ? 0 : Math.Min(j + z[j] - i, z[i - j]); while (i + k < n && EqualityComparer<T>.Default.Equals(s[k], s[i + k])) k++; if (j + z[j] < i + z[i]) j = i; } z[0] = n; return z; } public static int[] ZAlgorithm(string s) => ZAlgorithm(s.AsSpan()); public static int[] ZAlgorithm<T>(T[] s) => ZAlgorithm((ReadOnlySpan<T>)s); } } "),
new AclFileInfo(@"DataStructure/String/LCPArray.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] {  }, @"namespace AtCoder { public static partial class StringLib { public static int[] LCPArray<T>(ReadOnlySpan<T> s, int[] sa) { Debug.Assert(1 <= s.Length); int[] rnk = new int[s.Length]; for (int i = 0; i < s.Length; i++) { rnk[sa[i]] = i; } int[] lcp = new int[s.Length - 1]; int h = 0; for (int i = 0; i < s.Length; i++) { if (h > 0) h--; if (rnk[i] == 0) continue; int j = sa[rnk[i] - 1]; for (; j + h < s.Length && i + h < s.Length; h++) { if (!EqualityComparer<T>.Default.Equals(s[j + h], s[i + h])) break; } lcp[rnk[i] - 1] = h; } return lcp; } public static int[] LCPArray(string s, int[] sa) => LCPArray(s.AsSpan(), sa); public static int[] LCPArray<T>(T[] s, int[] sa) => LCPArray((ReadOnlySpan<T>)s, sa); } } "),
new AclFileInfo(@"DataStructure/String/SuffixArray.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] { @"DataStructure/String/Internal/InternalString.cs" }, @"namespace AtCoder { public static partial class StringLib { private static int[] SuffixArray<T>(ReadOnlyMemory<T> m) { var s = m.Span; var n = m.Length; var idx = Enumerable.Range(0, n).ToArray(); Array.Sort(idx, Compare); var s2 = new int[n]; var now = 0; for (int i = 0; i < idx.Length; i++) { if (i > 0 && !EqualityComparer<T>.Default.Equals(s[idx[i - 1]], s[idx[i]])) { now++; } s2[idx[i]] = now; } return Internal.String.SAIS(s2, now); int Compare(int l, int r) { var s = m.Span; return Comparer<T>.Default.Compare(s[l], s[r]); } } public static int[] SuffixArray(string s) { var n = s.Length; int[] s2 = s.Select(c => (int)c).ToArray(); return Internal.String.SAIS(s2, char.MaxValue); } public static int[] SuffixArray<T>(T[] s) => SuffixArray<T>(s.AsMemory()); public static int[] SuffixArray(int[] s, int upper) { Debug.Assert(0 <= upper); foreach (var si in s) { Debug.Assert(unchecked((uint)si) <= upper); } return Internal.String.SAIS(s, upper); } } } "),
new AclFileInfo(@"Math/Internal/InternalMath.cs", new string[] { @"AtCoder.Internal.InternalMath" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Math/MathLib.cs" }, @"namespace AtCoder.Internal { public static class InternalMath { public static long SafeMod(long x, long m) { x %= m; if (x < 0) x += m; return x; } public static (long, long) InvGCD(long a, long b) { a = SafeMod(a, b); if (a == 0) return (b, 0); long s = b, t = a; long m0 = 0, m1 = 1; long u; while (true) { if (t == 0) { if (m0 < 0) m0 += b / s; return (s, m0); } u = s / t; s -= t * u; m0 -= m1 * u; if (s == 0) { if (m1 < 0) m1 += b / t; return (t, m1); } u = t / s; t -= s * u; m1 -= m0 * u; } } private static readonly Dictionary<int, int> primitiveRootsCache = new Dictionary<int, int>() { { 2, 1 }, { 167772161, 3 }, { 469762049, 3 }, { 754974721, 11 }, { 998244353, 3 } }; public static int PrimitiveRoot(int m) { Debug.Assert(m >= 2); if (primitiveRootsCache.TryGetValue(m, out var p)) { return p; } return primitiveRootsCache[m] = Calculate(m); int Calculate(int m) { Span<int> divs = stackalloc int[20]; divs[0] = 2; int cnt = 1; int x = (m - 1) / 2; while (x % 2 == 0) { x >>= 1; } for (int i = 3; (long)i * i <= x; i += 2) { if (x % i == 0) { divs[cnt++] = i; while (x % i == 0) { x /= i; } } } if (x > 1) { divs[cnt++] = x; } for (int g = 2; ; g++) { bool ok = true; for (int i = 0; i < cnt; i++) { if (MathLib.PowMod(g, (m - 1) / divs[i], m) == 1) { ok = false; break; } } if (ok) { return g; } } } } } } "),
new AclFileInfo(@"Math/Internal/Butterfly.cs", new string[] { @"AtCoder.Internal.Butterfly<T>" }, new string[] { @"using System;" }, new string[] { @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder.Internal { public static class Butterfly<T> where T : struct, IStaticMod { private static StaticModInt<T>[] sumE = CalcurateSumE(); private static StaticModInt<T>[] sumIE = CalcurateSumIE(); public static void Calculate(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = 1; ph <= h; ph++) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var now = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p] * now; a[i + offset] = l + r; a[i + offset + p] = l - r; } now *= sumE[InternalBit.BSF(~(uint)s)]; } } } public static void CalculateInv(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = h; ph >= 1; ph--) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var iNow = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p]; a[i + offset] = l + r; a[i + offset + p] = StaticModInt<T>.Raw( unchecked((int)((ulong)(default(T).Mod + l.Value - r.Value) * (ulong)iNow.Value % default(T).Mod))); } iNow *= sumIE[InternalBit.BSF(~(uint)s)]; } } } private static StaticModInt<T>[] CalcurateSumE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumE.Length; i++) { sumE[i] = es[i] * now; now *= ies[i]; } return sumE; } private static StaticModInt<T>[] CalcurateSumIE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumIE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumIE.Length; i++) { sumIE[i] = ies[i] * now; now *= es[i]; } return sumIE; } } } "),
new AclFileInfo(@"Math/Internal/Barrett.cs", new string[] { @"AtCoder.Internal.Barrett" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Numerics;", @"using System.Runtime.Intrinsics;", @"using System.Runtime.Intrinsics.X86;", @"using System.Text;" }, new string[] {  }, @"namespace AtCoder.Internal { public class Barrett { public uint Mod { get; private set; } private ulong IM; public Barrett(uint m) { Mod = m; IM = unchecked((ulong)-1) / m + 1; } public uint Mul(uint a, uint b) { ulong z = a; z *= b; if (!Bmi2.X64.IsSupported) return (uint)(z % Mod); var x = Bmi2.X64.MultiplyNoFlags(z, IM); var v = unchecked((uint)(z - x * Mod)); if (Mod <= v) v += Mod; return v; } } } "),
new AclFileInfo(@"Bit/Internal/InternalBit.cs", new string[] { @"AtCoder.Internal.InternalBit" }, new string[] { @"using System.Diagnostics;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using System.Runtime.Intrinsics.X86;" }, new string[] {  }, @"namespace AtCoder.Internal { public static class InternalBit { public static int CeilPow2(int n) { var un = (uint)n; if (un <= 1) return 0; return BitOperations.Log2(un - 1) + 1; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int ExtractLowestSetBit(int n) { if (Bmi1.IsSupported) { return (int)Bmi1.ExtractLowestSetBit((uint)n); } return n & -n; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int BSF(uint n) { Debug.Assert(n >= 1); return BitOperations.TrailingZeroCount(n); } } } "),
new AclFileInfo(@"Graph/Internal/InternalSCCGraph.cs", new string[] { @"AtCoder.Internal.SCCGraph", @"AtCoder.Internal.SCCGraph.CSR", @"AtCoder.Internal.SCCGraph.Edge" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Internal { [DebuggerDisplay(""Vertices = {_n}, Edges = {edges.Count}"")] public class SCCGraph { private readonly int _n; private readonly List<Edge> edges; public int VerticesNumbers => _n; public SCCGraph(int n) { _n = n; edges = new List<Edge>(); } public void AddEdge(int from, int to) => edges.Add(new Edge(from, to)); public (int groupNum, int[] ids) SCCIDs() { var g = new CSR(_n, edges); int nowOrd = 0; int groupNum = 0; var visited = new Stack<int>(_n); var low = new int[_n]; var ord = Enumerable.Repeat(-1, _n).ToArray(); var ids = new int[_n]; for (int i = 0; i < ord.Length; i++) { if (ord[i] == -1) { DFS(i); } } foreach (ref var x in ids.AsSpan()) { x = groupNum - 1 - x; } return (groupNum, ids); void DFS(int v) { low[v] = nowOrd; ord[v] = nowOrd++; visited.Push(v); for (int i = g.Start[v]; i < g.Start[v + 1]; i++) { int to = g.EList[i]; if (ord[to] == -1) { DFS(to); low[v] = Math.Min(low[v], low[to]); } else { low[v] = Math.Min(low[v], ord[to]); } } if (low[v] == ord[v]) { while (true) { int u = visited.Pop(); ord[u] = _n; ids[u] = groupNum; if (u == v) { break; } } groupNum++; } } } public List<List<int>> SCC() { var (groupNum, ids) = SCCIDs(); var counts = new int[groupNum]; foreach (var x in ids) { counts[x]++; } var groups = new List<List<int>>(groupNum); for (int i = 0; i < groupNum; i++) { groups.Add(new List<int>(counts[i])); } for (int i = 0; i < ids.Length; i++) { groups[ids[i]].Add(i); } return groups; } private class CSR { public int[] Start { get; } public int[] EList { get; } public CSR(int n, List<Edge> edges) { Start = new int[n + 1]; EList = new int[edges.Count]; foreach (var e in edges) { Start[e.From + 1]++; } for (int i = 1; i <= n; i++) { Start[i] += Start[i - 1]; } var counter = new int[Start.Length]; Start.CopyTo(counter, 0); foreach (var e in edges) { EList[counter[e.From]++] = e.To; } } } [DebuggerDisplay(""From = {From}, To = {To}"")] private readonly struct Edge { public int From { get; } public int To { get; } public Edge(int from, int to) { From = from; To = to; } } } } "),
new AclFileInfo(@"DataStructure/String/Internal/InternalString.cs", new string[] { @"AtCoder.Internal.String" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Internal { public static class String { private static int[] SANaive(ReadOnlyMemory<int> sm) { var n = sm.Length; var sa = Enumerable.Range(0, n).ToArray(); Array.Sort(sa, Compare); return sa; int Compare(int l, int r) { var s = sm.Span; while (l < s.Length && r < s.Length) { if (s[l] != s[r]) { return s[l] - s[r]; } l++; r++; } return r - l; } } private static int[] SADoubling(ReadOnlyMemory<int> sm) { var s = sm.Span; var n = s.Length; var sa = Enumerable.Range(0, n).ToArray(); var rnk = new int[n]; var tmp = new int[n]; s.CopyTo(rnk); for (int k = 1; k < n; k <<= 1) { Array.Sort(sa, Compare); tmp[sa[0]] = 0; for (int i = 1; i < sa.Length; i++) { tmp[sa[i]] = tmp[sa[i - 1]] + (Compare(sa[i - 1], sa[i]) < 0 ? 1 : 0); } (tmp, rnk) = (rnk, tmp); int Compare(int x, int y) { if (rnk[x] != rnk[y]) { return rnk[x] - rnk[y]; } int rx = x + k < n ? rnk[x + k] : -1; int ry = y + k < n ? rnk[y + k] : -1; return rx - ry; } } return sa; } public static int[] SAIS(ReadOnlyMemory<int> sm, int upper) => SAIS(sm, upper, 10, 40); public static int[] SAIS(ReadOnlyMemory<int> sm, int upper, int thresholdNaive, int thresholdDouling) { var s = sm.Span; var n = s.Length; if (n == 0) { return Array.Empty<int>(); } else if (n == 1) { return new int[] { 0 }; } else if (n == 2) { if (s[0] < s[1]) { return new int[] { 0, 1 }; } else { return new int[] { 1, 0 }; } } else if (n < thresholdNaive) { return SANaive(sm); } else if (n < thresholdDouling) { return SADoubling(sm); } var sa = new int[n]; var ls = new bool[n]; for (int i = sa.Length - 2; i >= 0; i--) { ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]); } var sumL = new int[upper + 1]; var sumS = new int[upper + 1]; for (int i = 0; i < s.Length; i++) { if (!ls[i]) { sumS[s[i]]++; } else { sumL[s[i] + 1]++; } } for (int i = 0; i < sumL.Length; i++) { sumS[i] += sumL[i]; if (i < upper) { sumL[i + 1] += sumS[i]; } } var lmsMap = GetFilledArray(-1, n + 1); int m = 0; for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lmsMap[i] = m++; } } var lms = new List<int>(m); for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lms.Add(i); } } Induce(lms); if (m > 0) { var sortedLms = new List<int>(m); foreach (var v in sa) { if (lmsMap[v] != -1) { sortedLms.Add(v); } } var recS = new int[m]; var recUpper = 0; recS[lmsMap[sortedLms[0]]] = 0; for (int i = 1; i < sortedLms.Count; i++) { var l = sortedLms[i - 1]; var r = sortedLms[i]; var endL = (lmsMap[l] + 1 < m) ? lms[lmsMap[l] + 1] : n; var endR = (lmsMap[r] + 1 < m) ? lms[lmsMap[r] + 1] : n; var same = true; if (endL - l != endR - r) { same = false; } else { while (l < endL) { if (s[l] != s[r]) { break; } l++; r++; } if (l == n || s[l] != s[r]) { same = false; } } if (!same) { recUpper++; } recS[lmsMap[sortedLms[i]]] = recUpper; } var recSA = SAIS(recS, recUpper, thresholdNaive, thresholdDouling); for (int i = 0; i < sortedLms.Count; i++) { sortedLms[i] = lms[recSA[i]]; } Induce(sortedLms); } return sa; void Induce(List<int> lms) { var s = sm.Span; sa.AsSpan().Fill(-1); var buf = new int[sumS.Length]; sumS.AsSpan().CopyTo(buf); foreach (var d in lms) { if (d == n) { continue; } sa[buf[s[d]]++] = d; } sumL.AsSpan().CopyTo(buf); sa[buf[s[n - 1]]++] = n - 1; for (int i = 0; i < sa.Length; i++) { int v = sa[i]; if (v >= 1 && !ls[v - 1]) { sa[buf[s[v - 1]]++] = v - 1; } } sumL.AsSpan().CopyTo(buf); for (int i = sa.Length - 1; i >= 0; i--) { int v = sa[i]; if (v >= 1 && ls[v - 1]) { sa[--buf[s[v - 1] + 1]] = v - 1; } } } } private static T[] GetFilledArray<T>(T value, int length) { var result = new T[length]; result.AsSpan().Fill(value); return result; } } } "),
            });
    }
}
